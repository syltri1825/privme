Aides
Introduction
Méthodes disponibles
Introduction
Laravel inclut une variété de fonctions PHP "d'assistance" globales. Beaucoup de ces fonctions sont utilisées par le framework lui-même ; cependant, vous êtes libre de les utiliser dans vos propres applications si vous les trouvez pratiques.

Méthodes disponibles
Tableaux et objets
Arrêt :: accessible
Arrêt :: ajouter
Arr :: réduire
Arr::crossJoin
Arr :: diviser
Arr :: point
Arrêt :: sauf
Arr :: existe
Arr :: premier
Arr :: aplatir
Arr :: oublier
Arr :: obtenir
Arr :: a
Arr ::hasAny
Arr ::isAssoc
Arr::isList
Arr :: rejoindre
Arr::keyBy
Arr :: dernier
Arr ::map
Arrêt :: seulement
Arr :: plumer
Arr ::préfixe
Arr ::prependKeysWith
Arrêter :: tirer
Arrêt ::requête
Arr :: aléatoire
Arrêt :: set
Arrêt :: shuffle
Arr :: trier
Arr ::sortRécursif
Arr ::toCssClasses
Arr::undot
Arr :: où
Arr::whereNotNull
Arr :: wrap
data_fill
data_get
base de données
tête
dernière

Chemins
app_path
base_path
config_path
chemin_base_données
lang_path
mélanger
public_path
chemin_ressource
chemin_de_stockage

Cordes
__
nom_base_classe
e
preg_replace_array
Str :: après
Str::afterLast
Str::ascii
Str :: avant
Str::beforeLast
Str :: entre
Str :: betweenFirst
Str :: chameau
Str :: contient
Str::containsAll
Str::endWith
Str::extrait
Str :: finition
Str::titre
Str::inlineMarkdown
Str :: est
Str::isAscii
Str::isJson
Str::isUuid
Str::kebab
Str::lcfirst
Str::longueur
Str::limit
Str :: inférieur
Str::markdown
Str::masque
Str::orderedUuid
Str::padBoth
Str::padLeft
Str::padRight
Str::pluriel
Str::plurielStudly
Str::aléatoire
Str::supprimer
Str :: remplacer
Str::replaceArray
Str::replaceFirst
Str::replaceLast
Str :: reverse
Str :: singulier
Str :: limace
Str::serpent
Str :: écraser
Str::start
Str::startsWith
Str :: étudiant
Str::substr
Str::substrCount
Str::substrReplace
Str::swap
Str::titre
Str::toHtmlString
Str::ucfirst
Str :: ucsplit
Str :: majuscule
Str::uuid
Str::wordCount
Str::mots
chaîne
trans
trans_choice

Cordes fluides
après
aprèsDernier
ajouter
ascii
nom de base
avant de
avant dernière
entre
entrePremier
chameau
classBasename
contient
contientTout
dirname
se termine par
extrait
exactement
exploser
terminer
inlineMarkdown
est
estAscii
est vide
n'est pas vide
estJson
estUuid
kebab
lcfirst
longueur
limite
plus bas
ltrim
réduction
masque
match
matchAll
nouvelle ligne
padBoth
padGauche
padDroit
tuyau
pluriel
ajouter
retirer
remplacer
remplacerTableau
remplacerPremier
remplacerDernier
remplacerMatches
rtrim
analyse
singulier
limace
serpent
diviser
gargouillis
début
commence avec
studieusement
substr
substrReplace
échanger
robinet
test
Titre
garniture
ucfirst
ucsplit
plus haut
lorsque
quandContient
quandContientTout
quandvide
quandpasvide
quandCommencePar
quandEndsWith
quand exactement
quand est
quandEstAscii
quandEstUuid
quandTest
wordCount
mots

URL
action
actif
itinéraire
secure_asset
secure_url
pour acheminer
URL

Divers
avorter
abandonner_si
abandonner_sauf si
application
authentification
retour
bcrypt
Vide
diffuser
cache
class_uses_recursive
recueillir
configuration
biscuit
champ_csrf
csrf_token
décrypter
jj
expédition
décharger
Crypter
env
un événement
faux
rempli
Info
enregistreur
method_field
à présent
Agé de
optionnel
politique
réorienter
rapport
demande
sauvetage
résoudre
réponse
recommencez
session
robinet
lancer_si
jeter_sauf si
aujourd'hui
trait_uses_recursive
transformer
validateur
évaluer
voir
avec

Liste des méthodes
Tableaux et objets
Arr::accessible()
La Arr::accessibleméthode détermine si la valeur donnée est accessible au tableau :

use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
 
$isAccessible = Arr::accessible(['a' => 1, 'b' => 2]);
 
// true
 
$isAccessible = Arr::accessible(new Collection);
 
// true
 
$isAccessible = Arr::accessible('abc');
 
// false
 
$isAccessible = Arr::accessible(new stdClass);
 
// false

Arr::add()
La Arr::addméthode ajoute une paire clé/valeur donnée à un tableau si la clé donnée n'existe pas déjà dans le tableau ou est définie surnull :

use Illuminate\Support\Arr;
 
$array = Arr::add(['name' => 'Desk'], 'price', 100);
 
// ['name' => 'Desk', 'price' => 100]
 
$array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);
 
// ['name' => 'Desk', 'price' => 100]

Arr::collapse()
La Arr::collapseméthode réduit un tableau de tableaux en un seul tableau :

use Illuminate\Support\Arr;
 
$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
 
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

Arr::crossJoin()
La Arr::crossJoinméthode cross joint les tableaux donnés, renvoyant un produit cartésien avec toutes les permutations possibles :

use Illuminate\Support\Arr;
 
$matrix = Arr::crossJoin([1, 2], ['a', 'b']);
 
/*
    [
        [1, 'a'],
        [1, 'b'],
        [2, 'a'],
        [2, 'b'],
    ]
*/
 
$matrix = Arr::crossJoin([1, 2], ['a', 'b'], ['I', 'II']);
 
/*
    [
        [1, 'a', 'I'],
        [1, 'a', 'II'],
        [1, 'b', 'I'],
        [1, 'b', 'II'],
        [2, 'a', 'I'],
        [2, 'a', 'II'],
        [2, 'b', 'I'],
        [2, 'b', 'II'],
    ]
*/

Arr::divide()
La Arr::divideméthode renvoie deux tableaux : l'un contenant les clés et l'autre contenant les valeurs du tableau donné :

use Illuminate\Support\Arr;
 
[$keys, $values] = Arr::divide(['name' => 'Desk']);
 
// $keys: ['name']
 
// $values: ['Desk']

Arr::dot()
La Arr::dotméthode aplatit un tableau multidimensionnel en un tableau à un seul niveau qui utilise la notation "point" pour indiquer la profondeur :

use Illuminate\Support\Arr;
 
$array = ['products' => ['desk' => ['price' => 100]]];
 
$flattened = Arr::dot($array);
 
// ['products.desk.price' => 100]

Arr::except()
La Arr::exceptméthode supprime les paires clé/valeur données d'un tableau :

use Illuminate\Support\Arr;
 
$array = ['name' => 'Desk', 'price' => 100];
 
$filtered = Arr::except($array, ['price']);
 
// ['name' => 'Desk']

Arr::exists()
La Arr::existsméthode vérifie que la clé donnée existe dans le tableau fourni :

use Illuminate\Support\Arr;
 
$array = ['name' => 'John Doe', 'age' => 17];
 
$exists = Arr::exists($array, 'name');
 
// true
 
$exists = Arr::exists($array, 'salary');
 
// false

Arr::first()
La Arr::firstméthode renvoie le premier élément d'un tableau réussissant un test de vérité donné :

use Illuminate\Support\Arr;
 
$array = [100, 200, 300];
 
$first = Arr::first($array, function ($value, $key) {
    return $value >= 150;
});
 
// 200

Une valeur par défaut peut également être transmise comme troisième paramètre à la méthode. Cette valeur sera renvoyée si aucune valeur ne passe le test de vérité :

use Illuminate\Support\Arr;
 
$first = Arr::first($array, $callback, $default);

Arr::flatten()
La Arr::flattenméthode aplatit un tableau multidimensionnel en un tableau à un seul niveau :

use Illuminate\Support\Arr;
 
$array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];
 
$flattened = Arr::flatten($array);
 
// ['Joe', 'PHP', 'Ruby']

Arr::forget()
La Arr::forgetméthode supprime une paire clé/valeur donnée d'un tableau profondément imbriqué en utilisant la notation "point":

use Illuminate\Support\Arr;
 
$array = ['products' => ['desk' => ['price' => 100]]];
 
Arr::forget($array, 'products.desk');
 
// ['products' => []]

Arr::get()
La Arr::getméthode récupère une valeur à partir d'un tableau profondément imbriqué en utilisant la notation "point":

use Illuminate\Support\Arr;
 
$array = ['products' => ['desk' => ['price' => 100]]];
 
$price = Arr::get($array, 'products.desk.price');
 
// 100

La Arr::getméthode accepte également une valeur par défaut, qui sera renvoyée si la clé spécifiée n'est pas présente dans le tableau :

use Illuminate\Support\Arr;
 
$discount = Arr::get($array, 'products.desk.discount', 0);
 
// 0

Arr::has()
La Arr::hasméthode vérifie si un ou plusieurs éléments donnés existent dans un tableau en utilisant la notation "point":

use Illuminate\Support\Arr;
 
$array = ['product' => ['name' => 'Desk', 'price' => 100]];
 
$contains = Arr::has($array, 'product.name');
 
// true
 
$contains = Arr::has($array, ['product.price', 'product.discount']);
 
// false

Arr::hasAny()
La Arr::hasAnyméthode vérifie si un élément d'un ensemble donné existe dans un tableau en utilisant la notation "point":

use Illuminate\Support\Arr;
 
$array = ['product' => ['name' => 'Desk', 'price' => 100]];
 
$contains = Arr::hasAny($array, 'product.name');
 
// true
 
$contains = Arr::hasAny($array, ['product.name', 'product.discount']);
 
// true
 
$contains = Arr::hasAny($array, ['category', 'product.discount']);
 
// false

Arr::isAssoc()
La Arr::isAssocméthode retourne truesi le tableau donné est un tableau associatif. Un tableau est considéré comme "associatif" s'il n'a pas de clés numériques séquentielles commençant par zéro :

use Illuminate\Support\Arr;
 
$isAssoc = Arr::isAssoc(['product' => ['name' => 'Desk', 'price' => 100]]);
 
// true
 
$isAssoc = Arr::isAssoc([1, 2, 3]);
 
// false

Arr::isList()
La Arr::isListméthode renvoie truesi les clés du tableau donné sont des entiers séquentiels commençant à zéro :

use Illuminate\Support\Arr;
 
$isAssoc = Arr::isList(['foo', 'bar', 'baz']);
 
// true
 
$isAssoc = Arr::isList(['product' => ['name' => 'Desk', 'price' => 100]]);
 
// false

Arr::join()
La Arr::joinméthode joint les éléments du tableau avec une chaîne. En utilisant le deuxième argument de cette méthode, vous pouvez également spécifier la chaîne de jonction pour le dernier élément du tableau :

use Illuminate\Support\Arr;
 
$array = ['Tailwind', 'Alpine', 'Laravel', 'Livewire'];
 
$joined = Arr::join($array, ', ');
 
// Tailwind, Alpine, Laravel, Livewire
 
$joined = Arr::join($array, ', ', ' and ');
 
// Tailwind, Alpine, Laravel and Livewire

Arr::keyBy()
La Arr::keyByméthode clé le tableau par la clé donnée. Si plusieurs éléments ont la même clé, seul le dernier apparaîtra dans le nouveau tableau :

use Illuminate\Support\Arr;
 
$array = [
    ['product_id' => 'prod-100', 'name' => 'Desk'],
    ['product_id' => 'prod-200', 'name' => 'Chair'],
];
 
$keyed = Arr::keyBy($array, 'product_id');
 
/*
    [
        'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
        'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair'],
    ]
*/

Arr::last()
La Arr::lastméthode renvoie le dernier élément d'un tableau passant un test de vérité donné :

use Illuminate\Support\Arr;
 
$array = [100, 200, 300, 110];
 
$last = Arr::last($array, function ($value, $key) {
    return $value >= 150;
});
 
// 300

Une valeur par défaut peut être passée comme troisième argument à la méthode. Cette valeur sera renvoyée si aucune valeur ne passe le test de vérité :

use Illuminate\Support\Arr;
 
$last = Arr::last($array, $callback, $default);

Arr::map()
La Arr::mapméthode parcourt le tableau et transmet chaque valeur et clé au rappel donné. La valeur du tableau est remplacée par la valeur renvoyée par le rappel :

use Illuminate\Support\Arr;
 
$array = ['first' => 'james', 'last' => 'kirk'];
 
$mapped = Arr::map($array, function ($value, $key) {
    return ucfirst($value);
});
 
// ['first' => 'James', 'last' => 'Kirk']

Arr::only()
La Arr::onlyméthode renvoie uniquement les paires clé/valeur spécifiées du tableau donné :

use Illuminate\Support\Arr;
 
$array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];
 
$slice = Arr::only($array, ['name', 'price']);
 
// ['name' => 'Desk', 'price' => 100]

Arr::pluck()
La Arr::pluckméthode récupère toutes les valeurs d'une clé donnée à partir d'un tableau :

use Illuminate\Support\Arr;
 
$array = [
    ['developer' => ['id' => 1, 'name' => 'Taylor']],
    ['developer' => ['id' => 2, 'name' => 'Abigail']],
];
 
$names = Arr::pluck($array, 'developer.name');
 
// ['Taylor', 'Abigail']

Vous pouvez également spécifier comment vous souhaitez que la liste résultante soit saisie :

use Illuminate\Support\Arr;
 
$names = Arr::pluck($array, 'developer.name', 'developer.id');
 
// [1 => 'Taylor', 2 => 'Abigail']

Arr::prepend()
La Arr::prependméthode poussera un élément au début d'un tableau :

use Illuminate\Support\Arr;
 
$array = ['one', 'two', 'three', 'four'];
 
$array = Arr::prepend($array, 'zero');
 
// ['zero', 'one', 'two', 'three', 'four']

Si nécessaire, vous pouvez spécifier la clé à utiliser pour la valeur :

use Illuminate\Support\Arr;
 
$array = ['price' => 100];
 
$array = Arr::prepend($array, 'Desk', 'name');
 
// ['name' => 'Desk', 'price' => 100]

Arr::prependKeysWith()
Le Arr::prependKeysWithpréfixe tous les noms de clé d'un tableau associatif avec le préfixe donné :

use Illuminate\Support\Arr;
 
$array = [
    'name' => 'Desk',
    'price' => 100,
];
 
$keyed = Arr::prependKeysWith($array, 'product.');
 
/*
    [
        'product.name' => 'Desk',
        'product.price' => 100,
    ]
*/

Arr::pull()
La Arr::pullméthode renvoie et supprime une paire clé/valeur d'un tableau :

use Illuminate\Support\Arr;
 
$array = ['name' => 'Desk', 'price' => 100];
 
$name = Arr::pull($array, 'name');
 
// $name: Desk
 
// $array: ['price' => 100]

Une valeur par défaut peut être passée comme troisième argument à la méthode. Cette valeur sera renvoyée si la clé n'existe pas :

use Illuminate\Support\Arr;
 
$value = Arr::pull($array, $key, $default);

Arr::query()
La Arr::queryméthode convertit le tableau en une chaîne de requête :

use Illuminate\Support\Arr;
 
$array = [
    'name' => 'Taylor',
    'order' => [
        'column' => 'created_at',
        'direction' => 'desc'
    ]
];
 
Arr::query($array);
 
// name=Taylor&order[column]=created_at&order[direction]=desc

Arr::random()
La Arr::randomméthode renvoie une valeur aléatoire à partir d'un tableau :

use Illuminate\Support\Arr;
 
$array = [1, 2, 3, 4, 5];
 
$random = Arr::random($array);
 
// 4 - (retrieved randomly)

Vous pouvez également spécifier le nombre d'éléments à renvoyer comme deuxième argument facultatif. Notez que fournir cet argument renverra un tableau même si un seul élément est souhaité :

use Illuminate\Support\Arr;
 
$items = Arr::random($array, 2);
 
// [2, 5] - (retrieved randomly)

Arr::set()
La Arr::setméthode définit une valeur dans un tableau profondément imbriqué en utilisant la notation "point":

use Illuminate\Support\Arr;
 
$array = ['products' => ['desk' => ['price' => 100]]];
 
Arr::set($array, 'products.desk.price', 200);
 
// ['products' => ['desk' => ['price' => 200]]]

Arr::shuffle()
La Arr::shuffleméthode mélange aléatoirement les éléments du tableau :

use Illuminate\Support\Arr;
 
$array = Arr::shuffle([1, 2, 3, 4, 5]);
 
// [3, 2, 5, 1, 4] - (generated randomly)

Arr::sort()
La Arr::sortméthode trie un tableau par ses valeurs :

use Illuminate\Support\Arr;
 
$array = ['Desk', 'Table', 'Chair'];
 
$sorted = Arr::sort($array);
 
// ['Chair', 'Desk', 'Table']

Vous pouvez également trier le tableau en fonction des résultats d'une fermeture donnée :

use Illuminate\Support\Arr;
 
$array = [
    ['name' => 'Desk'],
    ['name' => 'Table'],
    ['name' => 'Chair'],
];
 
$sorted = array_values(Arr::sort($array, function ($value) {
    return $value['name'];
}));
 
/*
    [
        ['name' => 'Chair'],
        ['name' => 'Desk'],
        ['name' => 'Table'],
    ]
*/

Arr::sortRecursive()
La Arr::sortRecursiveméthode trie récursivement un tableau en utilisant la sortfonction pour les sous-tableaux indexés numériquement et la ksortfonction pour les sous-tableaux associatifs :

use Illuminate\Support\Arr;
 
$array = [
    ['Roman', 'Taylor', 'Li'],
    ['PHP', 'Ruby', 'JavaScript'],
    ['one' => 1, 'two' => 2, 'three' => 3],
];
 
$sorted = Arr::sortRecursive($array);
 
/*
    [
        ['JavaScript', 'PHP', 'Ruby'],
        ['one' => 1, 'three' => 3, 'two' => 2],
        ['Li', 'Roman', 'Taylor'],
    ]
*/

Arr::toCssClasses()
Le Arr::toCssClassescompile conditionnellement une chaîne de classe CSS. La méthode accepte un tableau de classes où la clé du tableau contient la ou les classes que vous souhaitez ajouter, tandis que la valeur est une expression booléenne. Si l'élément de tableau a une clé numérique, il sera toujours inclus dans la liste de classe rendue :

use Illuminate\Support\Arr;
 
$isActive = false;
$hasError = true;
 
$array = ['p-4', 'font-bold' => $isActive, 'bg-red' => $hasError];
 
$classes = Arr::toCssClasses($array);
 
/*
    'p-4 bg-red'
*/

Cette méthode alimente la fonctionnalité de Laravel permettant de fusionner des classes avec le sac d'attributs d'un composant Blade ainsi que la @class directive Blade .

Arr::undot()
La Arr::undotméthode développe un tableau unidimensionnel qui utilise la notation "point" en un tableau multidimensionnel :

use Illuminate\Support\Arr;
 
$array = [
    'user.name' => 'Kevin Malone',
    'user.occupation' => 'Accountant',
];
 
$array = Arr::undot($array);
 
// ['user' => ['name' => 'Kevin Malone', 'occupation' => 'Accountant']]

Arr::where()
La Arr::whereméthode filtre un tableau en utilisant la fermeture donnée :

use Illuminate\Support\Arr;
 
$array = [100, '200', 300, '400', 500];
 
$filtered = Arr::where($array, function ($value, $key) {
    return is_string($value);
});
 
// [1 => '200', 3 => '400']

Arr::whereNotNull()
La Arr::whereNotNullméthode supprime toutes les nullvaleurs du tableau donné :

use Illuminate\Support\Arr;
 
$array = [0, null];
 
$filtered = Arr::whereNotNull($array);
 
// [0 => 0]

Arr::wrap()
La Arr::wrapméthode enveloppe la valeur donnée dans un tableau. Si la valeur donnée est déjà un tableau, elle sera renvoyée sans modification :

use Illuminate\Support\Arr;
 
$string = 'Laravel';
 
$array = Arr::wrap($string);
 
// ['Laravel']

Si la valeur donnée est null, un tableau vide sera renvoyé :

use Illuminate\Support\Arr;
 
$array = Arr::wrap(null);
 
// []

data_fill()
La data_fillfonction définit une valeur manquante dans un tableau ou un objet imbriqué en utilisant la notation "point":

$data = ['products' => ['desk' => ['price' => 100]]];
 
data_fill($data, 'products.desk.price', 200);
 
// ['products' => ['desk' => ['price' => 100]]]
 
data_fill($data, 'products.desk.discount', 10);
 
// ['products' => ['desk' => ['price' => 100, 'discount' => 10]]]

Cette fonction accepte également les astérisques comme caractères génériques et remplira la cible en conséquence :

$data = [
    'products' => [
        ['name' => 'Desk 1', 'price' => 100],
        ['name' => 'Desk 2'],
    ],
];
 
data_fill($data, 'products.*.price', 200);
 
/*
    [
        'products' => [
            ['name' => 'Desk 1', 'price' => 100],
            ['name' => 'Desk 2', 'price' => 200],
        ],
    ]
*/

data_get()
La data_getfonction récupère une valeur à partir d'un tableau ou d'un objet imbriqué en utilisant la notation "point":

$data = ['products' => ['desk' => ['price' => 100]]];
 
$price = data_get($data, 'products.desk.price');
 
// 100

La data_getfonction accepte également une valeur par défaut, qui sera renvoyée si la clé spécifiée n'est pas trouvée :

$discount = data_get($data, 'products.desk.discount', 0);
 
// 0

La fonction accepte également les caractères génériques utilisant des astérisques, qui peuvent cibler n'importe quelle clé du tableau ou de l'objet :

$data = [
    'product-one' => ['name' => 'Desk 1', 'price' => 100],
    'product-two' => ['name' => 'Desk 2', 'price' => 150],
];
 
data_get($data, '*.name');
 
// ['Desk 1', 'Desk 2'];

data_set()
La data_setfonction définit une valeur dans un tableau ou un objet imbriqué en utilisant la notation "point":

$data = ['products' => ['desk' => ['price' => 100]]];
 
data_set($data, 'products.desk.price', 200);
 
// ['products' => ['desk' => ['price' => 200]]]

Cette fonction accepte également les caractères génériques utilisant des astérisques et définira des valeurs sur la cible en conséquence :

$data = [
    'products' => [
        ['name' => 'Desk 1', 'price' => 100],
        ['name' => 'Desk 2', 'price' => 150],
    ],
];
 
data_set($data, 'products.*.price', 200);
 
/*
    [
        'products' => [
            ['name' => 'Desk 1', 'price' => 200],
            ['name' => 'Desk 2', 'price' => 200],
        ],
    ]
*/

Par défaut, toutes les valeurs existantes sont écrasées. Si vous souhaitez uniquement définir une valeur si elle n'existe pas, vous pouvez passer falsecomme quatrième argument à la fonction :

$data = ['products' => ['desk' => ['price' => 100]]];
 
data_set($data, 'products.desk.price', 200, $overwrite = false);
 
// ['products' => ['desk' => ['price' => 100]]]

head()
La headfonction renvoie le premier élément du tableau donné :

$array = [100, 200, 300];
 
$first = head($array);
 
// 100

last()
La lastfonction renvoie le dernier élément du tableau donné :

$array = [100, 200, 300];
 
$last = last($array);
 
// 300

Chemins
app_path()
La app_pathfonction renvoie le chemin d'accès complet au apprépertoire de votre application. Vous pouvez également utiliser la app_pathfonction pour générer un chemin complet vers un fichier relatif au répertoire de l'application :

$path = app_path();
 
$path = app_path('Http/Controllers/Controller.php');

base_path()
La base_pathfonction renvoie le chemin d'accès complet au répertoire racine de votre application. Vous pouvez également utiliser la base_pathfonction pour générer un chemin complet vers un fichier donné relatif au répertoire racine du projet :

$path = base_path();
 
$path = base_path('vendor/bin');

config_path()
La config_pathfonction renvoie le chemin d'accès complet au configrépertoire de votre application. Vous pouvez également utiliser la config_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire de configuration de l'application :

$path = config_path();
 
$path = config_path('app.php');

database_path()
La database_pathfonction renvoie le chemin d'accès complet au databaserépertoire de votre application. Vous pouvez également utiliser la database_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire de la base de données :

$path = database_path();
 
$path = database_path('factories/UserFactory.php');

lang_path()
La lang_pathfonction renvoie le chemin d'accès complet au langrépertoire de votre application. Vous pouvez également utiliser la lang_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire :

$path = lang_path();
 
$path = lang_path('en/messages.php');

mix()
La mixfonction renvoie le chemin vers un fichier Mix versionné :

$path = mix('css/app.css');

public_path()
La public_pathfonction renvoie le chemin d'accès complet au publicrépertoire de votre application. Vous pouvez également utiliser la public_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire public :

$path = public_path();
 
$path = public_path('css/app.css');

resource_path()
La resource_pathfonction renvoie le chemin d'accès complet au resourcesrépertoire de votre application. Vous pouvez également utiliser la resource_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire des ressources :

$path = resource_path();
 
$path = resource_path('sass/app.scss');

storage_path()
La storage_pathfonction renvoie le chemin d'accès complet au storagerépertoire de votre application. Vous pouvez également utiliser la storage_pathfonction pour générer un chemin complet vers un fichier donné dans le répertoire de stockage :

$path = storage_path();
 
$path = storage_path('app/file.txt');

Cordes
__()
La __fonction traduit la chaîne de traduction ou la clé de traduction donnée à l'aide de vos fichiers de localisation :

echo __('Welcome to our application');
 
echo __('messages.welcome');

Si la chaîne ou la clé de traduction spécifiée n'existe pas, la __fonction renverra la valeur donnée. Ainsi, en utilisant l'exemple ci-dessus, la __fonction retournerait messages.welcomesi cette clé de traduction n'existe pas.

class_basename()
La class_basenamefonction renvoie le nom de classe de la classe donnée avec l'espace de noms de la classe supprimé :

$class = class_basename('Foo\Bar\Baz');
 
// Baz

e()
La efonction exécute la fonction de PHP htmlspecialcharsavec l' double_encodeoption définie truepar défaut :

echo e('<html>foo</html>');
 
// &lt;html&gt;foo&lt;/html&gt;

preg_replace_array()
La preg_replace_arrayfonction remplace un motif donné dans la chaîne de manière séquentielle à l'aide d'un tableau :

$string = 'The event will take place between :start and :end';
 
$replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string);
 
// The event will take place between 8:30 and 9:00

Str::after()
La Str::afterméthode renvoie tout après la valeur donnée dans une chaîne. La chaîne entière sera renvoyée si la valeur n'existe pas dans la chaîne :

use Illuminate\Support\Str;
 
$slice = Str::after('This is my name', 'This is');
 
// ' my name'

Str::afterLast()
La Str::afterLastméthode renvoie tout après la dernière occurrence de la valeur donnée dans une chaîne. La chaîne entière sera renvoyée si la valeur n'existe pas dans la chaîne :

use Illuminate\Support\Str;
 
$slice = Str::afterLast('App\Http\Controllers\Controller', '\\');
 
// 'Controller'

Str::ascii()
La Str::asciiméthode tentera de translittérer la chaîne en une valeur ASCII :

use Illuminate\Support\Str;
 
$slice = Str::ascii('û');
 
// 'u'

Str::before()
La Str::beforeméthode renvoie tout ce qui précède la valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$slice = Str::before('This is my name', 'my name');
 
// 'This is '

Str::beforeLast()
La Str::beforeLastméthode renvoie tout avant la dernière occurrence de la valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$slice = Str::beforeLast('This is my name', 'is');
 
// 'This '

Str::between()
La Str::betweenméthode renvoie la partie d'une chaîne entre deux valeurs :

use Illuminate\Support\Str;
 
$slice = Str::between('This is my name', 'This', 'name');
 
// ' is my '

Str::betweenFirst()
La Str::betweenFirstméthode renvoie la plus petite portion possible d'une chaîne entre deux valeurs :

use Illuminate\Support\Str;
 
$slice = Str::betweenFirst('[a] bc [d]', '[', ']');
 
// 'a'

Str::camel()
La Str::camelméthode convertit la chaîne donnée en camelCase:

use Illuminate\Support\Str;
 
$converted = Str::camel('foo_bar');
 
// fooBar

Str::contains()
La Str::containsméthode détermine si la chaîne donnée contient la valeur donnée. Cette méthode est sensible à la casse :

use Illuminate\Support\Str;
 
$contains = Str::contains('This is my name', 'my');
 
// true

Vous pouvez également passer un tableau de valeurs pour déterminer si la chaîne donnée contient l'une des valeurs du tableau :

use Illuminate\Support\Str;
 
$contains = Str::contains('This is my name', ['my', 'foo']);
 
// true

Str::containsAll()
La Str::containsAllméthode détermine si la chaîne donnée contient toutes les valeurs d'un tableau donné :

use Illuminate\Support\Str;
 
$containsAll = Str::containsAll('This is my name', ['my', 'name']);
 
// true

Str::endsWith()
La Str::endsWithméthode détermine si la chaîne donnée se termine par la valeur donnée :

use Illuminate\Support\Str;
 
$result = Str::endsWith('This is my name', 'name');
 
// true

Vous pouvez également passer un tableau de valeurs pour déterminer si la chaîne donnée se termine par l'une des valeurs du tableau :

use Illuminate\Support\Str;
 
$result = Str::endsWith('This is my name', ['name', 'foo']);
 
// true
 
$result = Str::endsWith('This is my name', ['this', 'foo']);
 
// false

Str::excerpt()
La Str::excerptméthode extrait un extrait d'une chaîne donnée qui correspond à la première instance d'une phrase dans cette chaîne :

use Illuminate\Support\Str;
 
$excerpt = Str::excerpt('This is my name', 'my', [
    'radius' => 3
]);
 
// '...is my na...'

L' radiusoption, qui par défaut est 100, vous permet de définir le nombre de caractères qui doivent apparaître de chaque côté de la chaîne tronquée.

De plus, vous pouvez utiliser l' omissionoption pour définir la chaîne qui sera préfixée et ajoutée à la chaîne tronquée :

use Illuminate\Support\Str;
 
$excerpt = Str::excerpt('This is my name', 'name', [
    'radius' => 3,
    'omission' => '(...) '
]);
 
// '(...) my name'

Str::finish()
La Str::finishméthode ajoute une seule instance de la valeur donnée à une chaîne si elle ne se termine pas déjà par cette valeur :

use Illuminate\Support\Str;
 
$adjusted = Str::finish('this/string', '/');
 
// this/string/
 
$adjusted = Str::finish('this/string/', '/');
 
// this/string/

Str::headline()
La Str::headlineméthode convertira les chaînes délimitées par la casse, les traits d'union ou les traits de soulignement en une chaîne délimitée par des espaces avec la première lettre de chaque mot en majuscule :

use Illuminate\Support\Str;
 
$headline = Str::headline('steve_jobs');
 
// Steve Jobs
 
$headline = Str::headline('EmailNotificationSent');
 
// Email Notification Sent

Str::inlineMarkdown()
La Str::inlineMarkdownméthode convertit le Markdown à saveur GitHub en HTML intégré à l'aide de CommonMark . Cependant, contrairement à la markdownméthode, elle n'encapsule pas tout le code HTML généré dans un élément de niveau bloc :

use Illuminate\Support\Str;
 
$html = Str::inlineMarkdown('**Laravel**');
 
// <strong>Laravel</strong>

Str::is()
La Str::isméthode détermine si une chaîne donnée correspond à un modèle donné. Les astérisques peuvent être utilisés comme valeurs génériques :

use Illuminate\Support\Str;
 
$matches = Str::is('foo*', 'foobar');
 
// true
 
$matches = Str::is('baz*', 'foobar');
 
// false

Str::isAscii()
La Str::isAsciiméthode détermine si une chaîne donnée est en ASCII 7 bits :

use Illuminate\Support\Str;
 
$isAscii = Str::isAscii('Taylor');
 
// true
 
$isAscii = Str::isAscii('ü');
 
// false

Str::isJson()
La Str::isJsonméthode détermine si la chaîne donnée est un JSON valide :

use Illuminate\Support\Str;
 
$result = Str::isJson('[1,2,3]');
 
// true
 
$result = Str::isJson('{"first": "John", "last": "Doe"}');
 
// true
 
$result = Str::isJson('{first: "John", last: "Doe"}');
 
// false

Str::isUuid()
La Str::isUuidméthode détermine si la chaîne donnée est un UUID valide :

use Illuminate\Support\Str;
 
$isUuid = Str::isUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de');
 
// true
 
$isUuid = Str::isUuid('laravel');
 
// false

Str::kebab()
La Str::kebabméthode convertit la chaîne donnée en kebab-case:

use Illuminate\Support\Str;
 
$converted = Str::kebab('fooBar');
 
// foo-bar

Str::lcfirst()
La Str::lcfirstméthode renvoie la chaîne donnée avec le premier caractère en minuscule :

use Illuminate\Support\Str;
 
$string = Str::lcfirst('Foo Bar');
 
// foo Bar

Str::length()
La Str::lengthméthode renvoie la longueur de la chaîne donnée :

use Illuminate\Support\Str;
 
$length = Str::length('Laravel');
 
// 7

Str::limit()
La Str::limitméthode tronque la chaîne donnée à la longueur spécifiée :

use Illuminate\Support\Str;
 
$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20);
 
// The quick brown fox...

Vous pouvez passer un troisième argument à la méthode pour changer la chaîne qui sera ajoutée à la fin de la chaîne tronquée :

use Illuminate\Support\Str;
 
$truncated = Str::limit('The quick brown fox jumps over the lazy dog', 20, ' (...)');
 
// The quick brown fox (...)

Str::lower()
La Str::lowerméthode convertit la chaîne donnée en minuscule :

use Illuminate\Support\Str;
 
$converted = Str::lower('LARAVEL');
 
// laravel

Str::markdown()
La Str::markdownméthode convertit le Markdown aromatisé GitHub en HTML à l'aide de CommonMark :

use Illuminate\Support\Str;
 
$html = Str::markdown('# Laravel');
 
// <h1>Laravel</h1>
 
$html = Str::markdown('# Taylor <b>Otwell</b>', [
    'html_input' => 'strip',
]);
 
// <h1>Taylor Otwell</h1>

Str::mask()
La Str::maskméthode masque une partie d'une chaîne avec un caractère répété et peut être utilisée pour masquer des segments de chaînes tels que des adresses e-mail et des numéros de téléphone :

use Illuminate\Support\Str;
 
$string = Str::mask('taylor@example.com', '*', 3);
 
// tay***************

Si nécessaire, vous fournissez un nombre négatif comme troisième argument à la maskméthode, qui demandera à la méthode de commencer le masquage à la distance donnée de la fin de la chaîne :

$string = Str::mask('taylor@example.com', '*', -15, 3);
 
// tay***@example.com

Str::orderedUuid()
Le Str::orderedUuidprocédé génère un UUID "timestamp first" qui peut être stocké efficacement dans une colonne de base de données indexée. Chaque UUID généré à l'aide de cette méthode sera trié après les UUID précédemment générés à l'aide de la méthode :

use Illuminate\Support\Str;
 
return (string) Str::orderedUuid();

Str::padBoth()
La Str::padBothméthode encapsule la fonction PHP str_pad, remplissant les deux côtés d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::padBoth('James', 10, '_');
 
// '__James___'
 
$padded = Str::padBoth('James', 10);
 
// '  James   '

Str::padLeft()
La Str::padLeftméthode encapsule la fonction PHP str_pad, remplissant le côté gauche d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::padLeft('James', 10, '-=');
 
// '-=-=-James'
 
$padded = Str::padLeft('James', 10);
 
// '     James'

Str::padRight()
La Str::padRightméthode encapsule la fonction PHP str_pad, remplissant le côté droit d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::padRight('James', 10, '-');
 
// 'James-----'
 
$padded = Str::padRight('James', 10);
 
// 'James     '

Str::plural()
La Str::pluralméthode convertit une chaîne de mots au singulier en sa forme plurielle. Cette fonction prend en charge toutes les langues prises en charge par le pluraliseur de Laravel :

use Illuminate\Support\Str;
 
$plural = Str::plural('car');
 
// cars
 
$plural = Str::plural('child');
 
// children

Vous pouvez fournir un entier comme deuxième argument à la fonction pour récupérer la forme singulière ou plurielle de la chaîne :

use Illuminate\Support\Str;
 
$plural = Str::plural('child', 2);
 
// children
 
$singular = Str::plural('child', 1);
 
// child

Str::pluralStudly()
La Str::pluralStudlyméthode convertit une chaîne de mots au singulier formatée en majuscules studly en sa forme plurielle. Cette fonction prend en charge toutes les langues prises en charge par le pluraliseur de Laravel :

use Illuminate\Support\Str;
 
$plural = Str::pluralStudly('VerifiedHuman');
 
// VerifiedHumans
 
$plural = Str::pluralStudly('UserFeedback');
 
// UserFeedback

Vous pouvez fournir un entier comme deuxième argument à la fonction pour récupérer la forme singulière ou plurielle de la chaîne :

use Illuminate\Support\Str;
 
$plural = Str::pluralStudly('VerifiedHuman', 2);
 
// VerifiedHumans
 
$singular = Str::pluralStudly('VerifiedHuman', 1);
 
// VerifiedHuman

Str::random()
La Str::randomméthode génère une chaîne aléatoire de la longueur spécifiée. Cette fonction utilise la fonction de PHPrandom_bytes :

use Illuminate\Support\Str;
 
$random = Str::random(40);

Str::remove()
La Str::removeméthode supprime la valeur ou le tableau de valeurs donné de la chaîne :

use Illuminate\Support\Str;
 
$string = 'Peter Piper picked a peck of pickled peppers.';
 
$removed = Str::remove('e', $string);
 
// Ptr Pipr pickd a pck of pickld ppprs.

Vous pouvez également passer falseun troisième argument à la removeméthode pour ignorer la casse lors de la suppression de chaînes.

Str::replace()
La Str::replaceméthode remplace une chaîne donnée dans la chaîne :

use Illuminate\Support\Str;
 
$string = 'Laravel 8.x';
 
$replaced = Str::replace('8.x', '9.x', $string);
 
// Laravel 9.x

Str::replaceArray()
La Str::replaceArrayméthode remplace séquentiellement une valeur donnée dans la chaîne à l'aide d'un tableau :

use Illuminate\Support\Str;
 
$string = 'The event will take place between ? and ?';
 
$replaced = Str::replaceArray('?', ['8:30', '9:00'], $string);
 
// The event will take place between 8:30 and 9:00

Str::replaceFirst()
La Str::replaceFirstméthode remplace la première occurrence d'une valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$replaced = Str::replaceFirst('the', 'a', 'the quick brown fox jumps over the lazy dog');
 
// a quick brown fox jumps over the lazy dog

Str::replaceLast()
La Str::replaceLastméthode remplace la dernière occurrence d'une valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$replaced = Str::replaceLast('the', 'a', 'the quick brown fox jumps over the lazy dog');
 
// the quick brown fox jumps over a lazy dog

Str::reverse()
La Str::reverseméthode inverse la chaîne donnée :

use Illuminate\Support\Str;
 
$reversed = Str::reverse('Hello World');
 
// dlroW olleH

Str::singular()
La Str::singularméthode convertit une chaîne en sa forme singulière. Cette fonction prend en charge toutes les langues prises en charge par le pluraliseur de Laravel :

use Illuminate\Support\Str;
 
$singular = Str::singular('cars');
 
// car
 
$singular = Str::singular('children');
 
// child

Str::slug()
La Str::slugméthode génère un "slug" convivial pour l'URL à partir de la chaîne donnée :

use Illuminate\Support\Str;
 
$slug = Str::slug('Laravel 5 Framework', '-');
 
// laravel-5-framework

Str::snake()
La Str::snakeméthode convertit la chaîne donnée en snake_case:

use Illuminate\Support\Str;
 
$converted = Str::snake('fooBar');
 
// foo_bar
 
$converted = Str::snake('fooBar', '-');
 
// foo-bar

Str::squish()
La Str::squishméthode supprime tous les espaces blancs superflus d'une chaîne, y compris les espaces blancs superflus entre les mots :

use Illuminate\Support\Str;
 
$string = Str::squish('    laravel    framework    ');
 
// laravel framework

Str::start()
La Str::startméthode ajoute une seule instance de la valeur donnée à une chaîne si elle ne commence pas déjà par cette valeur :

use Illuminate\Support\Str;
 
$adjusted = Str::start('this/string', '/');
 
// /this/string
 
$adjusted = Str::start('/this/string', '/');
 
// /this/string

Str::startsWith()
La Str::startsWithméthode détermine si la chaîne donnée commence par la valeur donnée :

use Illuminate\Support\Str;
 
$result = Str::startsWith('This is my name', 'This');
 
// true

Si un tableau de valeurs possibles est passé, la startsWithméthode retournera truesi la chaîne commence par l'une des valeurs données :

$result = Str::startsWith('This is my name', ['This', 'That', 'There']);
 
// true

Str::studly()
La Str::studlyméthode convertit la chaîne donnée en StudlyCase:

use Illuminate\Support\Str;
 
$converted = Str::studly('foo_bar');
 
// FooBar

Str::substr()
La Str::substrméthode renvoie la portion de chaîne spécifiée par les paramètres start et length :

use Illuminate\Support\Str;
 
$converted = Str::substr('The Laravel Framework', 4, 7);
 
// Laravel

Str::substrCount()
La Str::substrCountméthode renvoie le nombre d'occurrences d'une valeur donnée dans la chaîne donnée :

use Illuminate\Support\Str;
 
$count = Str::substrCount('If you like ice cream, you will like snow cones.', 'like');
 
// 2

Str::substrReplace()
La Str::substrReplaceméthode remplace le texte dans une partie d'une chaîne, en commençant à la position spécifiée par le troisième argument et en remplaçant le nombre de caractères spécifié par le quatrième argument. Le passage 0au quatrième argument de la méthode insère la chaîne à la position spécifiée sans remplacer aucun des caractères existants dans la chaîne :

use Illuminate\Support\Str;
 
$result = Str::substrReplace('1300', ':', 2);
// 13:
 
$result = Str::substrReplace('1300', ':', 2, 0);
// 13:00

Str::swap()
La Str::swapméthode remplace plusieurs valeurs dans la chaîne donnée à l'aide de la strtrfonction PHP :

use Illuminate\Support\Str;
 
$string = Str::swap([
    'Tacos' => 'Burritos',
    'great' => 'fantastic',
], 'Tacos are great!');
 
// Burritos are fantastic!

Str::title()
La Str::titleméthode convertit la chaîne donnée en Title Case:

use Illuminate\Support\Str;
 
$converted = Str::title('a nice title uses the correct case');
 
// A Nice Title Uses The Correct Case

Str::toHtmlString()
La Str::toHtmlStringméthode convertit l'instance de chaîne en une instance de Illuminate\Support\HtmlString, qui peut être affichée dans les modèles Blade :

use Illuminate\Support\Str;
 
$htmlString = Str::of('Nuno Maduro')->toHtmlString();

Str::ucfirst()
La Str::ucfirstméthode renvoie la chaîne donnée avec le premier caractère en majuscule :

use Illuminate\Support\Str;
 
$string = Str::ucfirst('foo bar');
 
// Foo bar

Str::ucsplit()
La Str::ucsplitméthode divise la chaîne donnée en un tableau par des caractères majuscules :

use Illuminate\Support\Str;
 
$segments = Str::ucsplit('FooBar');
 
// [0 => 'Foo', 1 => 'Bar']

Str::upper()
La Str::upperméthode convertit la chaîne donnée en majuscule :

use Illuminate\Support\Str;
 
$string = Str::upper('laravel');
 
// LARAVEL

Str::uuid()
La Str::uuidméthode génère un UUID (version 4) :

use Illuminate\Support\Str;
 
return (string) Str::uuid();

Str::wordCount()
La Str::wordCountméthode renvoie le nombre de mots que contient une chaîne :

use Illuminate\Support\Str;
 
Str::wordCount('Hello, world!'); // 2

Str::words()
La Str::wordsméthode limite le nombre de mots dans une chaîne. Une chaîne supplémentaire peut être passée à cette méthode via son troisième argument pour spécifier quelle chaîne doit être ajoutée à la fin de la chaîne tronquée :

use Illuminate\Support\Str;
 
return Str::words('Perfectly balanced, as all things should be.', 3, ' >>>');
 
// Perfectly balanced, as >>>

str()
La strfonction renvoie une nouvelle Illuminate\Support\Stringableinstance de la chaîne donnée. Cette fonction est équivalente à la Str::ofméthode :

$string = str('Taylor')->append(' Otwell');
 
// 'Taylor Otwell'

Si aucun argument n'est fourni à la strfonction, la fonction renvoie une instance deIlluminate\Support\Str :

$snake = str()->snake('FooBar');
 
// 'foo_bar'

trans()
La transfonction traduit la clé de traduction donnée en utilisant vos fichiers de localisation :

echo trans('messages.welcome');

Si la clé de traduction spécifiée n'existe pas, la transfonction renverra la clé donnée. Ainsi, en utilisant l'exemple ci-dessus, la transfonction retournerait messages.welcomesi la clé de traduction n'existe pas.

trans_choice()
La trans_choicefonction traduit la clé de traduction donnée avec inflexion :

echo trans_choice('messages.notifications', $unreadCount);

Si la clé de traduction spécifiée n'existe pas, la trans_choicefonction renverra la clé donnée. Ainsi, en utilisant l'exemple ci-dessus, la trans_choicefonction retournerait messages.notificationssi la clé de traduction n'existe pas.

Cordes fluides
Les chaînes fluides fournissent une interface orientée objet plus fluide pour travailler avec des valeurs de chaîne, ce qui vous permet d'enchaîner plusieurs opérations de chaîne à l'aide d'une syntaxe plus lisible par rapport aux opérations de chaîne traditionnelles.

after
La afterméthode renvoie tout après la valeur donnée dans une chaîne. La chaîne entière sera renvoyée si la valeur n'existe pas dans la chaîne :

use Illuminate\Support\Str;
 
$slice = Str::of('This is my name')->after('This is');
 
// ' my name'

afterLast
La afterLastméthode renvoie tout après la dernière occurrence de la valeur donnée dans une chaîne. La chaîne entière sera renvoyée si la valeur n'existe pas dans la chaîne :

use Illuminate\Support\Str;
 
$slice = Str::of('App\Http\Controllers\Controller')->afterLast('\\');
 
// 'Controller'

append
La appendméthode ajoute les valeurs données à la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('Taylor')->append(' Otwell');
 
// 'Taylor Otwell'

ascii
La asciiméthode tentera de translittérer la chaîne en une valeur ASCII :

use Illuminate\Support\Str;
 
$string = Str::of('ü')->ascii();
 
// 'u'

basename
La basenameméthode renverra le composant de nom de fin de la chaîne donnée :

use Illuminate\Support\Str;
 
$string = Str::of('/foo/bar/baz')->basename();
 
// 'baz'

Si nécessaire, vous pouvez fournir une "extension" qui sera supprimée du composant de fin :

use Illuminate\Support\Str;
 
$string = Str::of('/foo/bar/baz.jpg')->basename('.jpg');
 
// 'baz'

before
La beforeméthode renvoie tout ce qui précède la valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$slice = Str::of('This is my name')->before('my name');
 
// 'This is '

beforeLast
La beforeLastméthode renvoie tout avant la dernière occurrence de la valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$slice = Str::of('This is my name')->beforeLast('is');
 
// 'This '

between
La betweenméthode renvoie la partie d'une chaîne entre deux valeurs :

use Illuminate\Support\Str;
 
$converted = Str::of('This is my name')->between('This', 'name');
 
// ' is my '

betweenFirst
La betweenFirstméthode renvoie la plus petite portion possible d'une chaîne entre deux valeurs :

use Illuminate\Support\Str;
 
$converted = Str::of('[a] bc [d]')->betweenFirst('[', ']');
 
// 'a'

camel
La camelméthode convertit la chaîne donnée en camelCase:

use Illuminate\Support\Str;
 
$converted = Str::of('foo_bar')->camel();
 
// fooBar

classBasename
La classBasenameméthode renvoie le nom de classe de la classe donnée avec l'espace de noms de la classe supprimé :

use Illuminate\Support\Str;
 
$class = Str::of('Foo\Bar\Baz')->classBasename();
 
// Baz

contains
La containsméthode détermine si la chaîne donnée contient la valeur donnée. Cette méthode est sensible à la casse :

use Illuminate\Support\Str;
 
$contains = Str::of('This is my name')->contains('my');
 
// true

Vous pouvez également passer un tableau de valeurs pour déterminer si la chaîne donnée contient l'une des valeurs du tableau :

use Illuminate\Support\Str;
 
$contains = Str::of('This is my name')->contains(['my', 'foo']);
 
// true

containsAll
La containsAllméthode détermine si la chaîne donnée contient toutes les valeurs du tableau donné :

use Illuminate\Support\Str;
 
$containsAll = Str::of('This is my name')->containsAll(['my', 'name']);
 
// true

dirname
La dirnameméthode renvoie la partie du répertoire parent de la chaîne donnée :

use Illuminate\Support\Str;
 
$string = Str::of('/foo/bar/baz')->dirname();
 
// '/foo/bar'

Si nécessaire, vous pouvez spécifier le nombre de niveaux de répertoire que vous souhaitez supprimer de la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('/foo/bar/baz')->dirname(2);
 
// '/foo'

excerpt
La excerptméthode extrait un extrait de la chaîne qui correspond à la première instance d'une phrase dans cette chaîne :

use Illuminate\Support\Str;
 
$excerpt = Str::of('This is my name')->excerpt('my', [
    'radius' => 3
]);
 
// '...is my na...'

L' radiusoption, qui par défaut est 100, vous permet de définir le nombre de caractères qui doivent apparaître de chaque côté de la chaîne tronquée.

De plus, vous pouvez utiliser l' omissionoption pour modifier la chaîne qui sera préfixée et ajoutée à la chaîne tronquée :

use Illuminate\Support\Str;
 
$excerpt = Str::of('This is my name')->excerpt('name', [
    'radius' => 3,
    'omission' => '(...) '
]);
 
// '(...) my name'

endsWith
La endsWithméthode détermine si la chaîne donnée se termine par la valeur donnée :

use Illuminate\Support\Str;
 
$result = Str::of('This is my name')->endsWith('name');
 
// true

Vous pouvez également passer un tableau de valeurs pour déterminer si la chaîne donnée se termine par l'une des valeurs du tableau :

use Illuminate\Support\Str;
 
$result = Str::of('This is my name')->endsWith(['name', 'foo']);
 
// true
 
$result = Str::of('This is my name')->endsWith(['this', 'foo']);
 
// false

exactly
La exactlyméthode détermine si la chaîne donnée correspond exactement à une autre chaîne :

use Illuminate\Support\Str;
 
$result = Str::of('Laravel')->exactly('Laravel');
 
// true

explode
La explodeméthode fractionne la chaîne par le délimiteur donné et renvoie une collection contenant chaque section de la chaîne fractionnée :

use Illuminate\Support\Str;
 
$collection = Str::of('foo bar baz')->explode(' ');
 
// collect(['foo', 'bar', 'baz'])

finish
La finishméthode ajoute une seule instance de la valeur donnée à une chaîne si elle ne se termine pas déjà par cette valeur :

use Illuminate\Support\Str;
 
$adjusted = Str::of('this/string')->finish('/');
 
// this/string/
 
$adjusted = Str::of('this/string/')->finish('/');
 
// this/string/

inlineMarkdown
La inlineMarkdownméthode convertit le Markdown à saveur GitHub en HTML intégré à l'aide de CommonMark . Cependant, contrairement à la markdownméthode, elle n'encapsule pas tout le code HTML généré dans un élément de niveau bloc :

use Illuminate\Support\Str;
 
$html = Str::of('**Laravel**')->inlineMarkdown();
 
// <strong>Laravel</strong>

is
La isméthode détermine si une chaîne donnée correspond à un modèle donné. Les astérisques peuvent être utilisés comme valeurs génériques

use Illuminate\Support\Str;
 
$matches = Str::of('foobar')->is('foo*');
 
// true
 
$matches = Str::of('foobar')->is('baz*');
 
// false

isAscii
La isAsciiméthode détermine si une chaîne donnée est une chaîne ASCII :

use Illuminate\Support\Str;
 
$result = Str::of('Taylor')->isAscii();
 
// true
 
$result = Str::of('ü')->isAscii();
 
// false

isEmpty
La isEmptyméthode détermine si la chaîne donnée est vide :

use Illuminate\Support\Str;
 
$result = Str::of('  ')->trim()->isEmpty();
 
// true
 
$result = Str::of('Laravel')->trim()->isEmpty();
 
// false

isNotEmpty
La isNotEmptyméthode détermine si la chaîne donnée n'est pas vide :

use Illuminate\Support\Str;
 
$result = Str::of('  ')->trim()->isNotEmpty();
 
// false
 
$result = Str::of('Laravel')->trim()->isNotEmpty();
 
// true

isJson
La isJsonméthode détermine si une chaîne donnée est un JSON valide :

use Illuminate\Support\Str;
 
$result = Str::of('[1,2,3]')->isJson();
 
// true
 
$result = Str::of('{"first": "John", "last": "Doe"}')->isJson();
 
// true
 
$result = Str::of('{first: "John", last: "Doe"}')->isJson();
 
// false

isUuid
La isUuidméthode détermine si une chaîne donnée est un UUID :

use Illuminate\Support\Str;
 
$result = Str::of('5ace9ab9-e9cf-4ec6-a19d-5881212a452c')->isUuid();
 
// true
 
$result = Str::of('Taylor')->isUuid();
 
// false

kebab
La kebabméthode convertit la chaîne donnée en kebab-case:

use Illuminate\Support\Str;
 
$converted = Str::of('fooBar')->kebab();
 
// foo-bar

lcfirst
La lcfirstméthode renvoie la chaîne donnée avec le premier caractère en minuscule :

use Illuminate\Support\Str;
 
$string = Str::of('Foo Bar')->lcfirst();
 
// foo Bar

length
La lengthméthode renvoie la longueur de la chaîne donnée :

use Illuminate\Support\Str;
 
$length = Str::of('Laravel')->length();
 
// 7

limit
La limitméthode tronque la chaîne donnée à la longueur spécifiée :

use Illuminate\Support\Str;
 
$truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20);
 
// The quick brown fox...

Vous pouvez également passer un deuxième argument pour changer la chaîne qui sera ajoutée à la fin de la chaîne tronquée :

use Illuminate\Support\Str;
 
$truncated = Str::of('The quick brown fox jumps over the lazy dog')->limit(20, ' (...)');
 
// The quick brown fox (...)

lower
La lowerméthode convertit la chaîne donnée en minuscule :

use Illuminate\Support\Str;
 
$result = Str::of('LARAVEL')->lower();
 
// 'laravel'

ltrim
La ltrimméthode coupe le côté gauche de la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('  Laravel  ')->ltrim();
 
// 'Laravel  '
 
$string = Str::of('/Laravel/')->ltrim('/');
 
// 'Laravel/'

markdown
La markdownméthode convertit le Markdown à saveur GitHub en HTML :

use Illuminate\Support\Str;
 
$html = Str::of('# Laravel')->markdown();
 
// <h1>Laravel</h1>
 
$html = Str::of('# Taylor <b>Otwell</b>')->markdown([
    'html_input' => 'strip',
]);
 
// <h1>Taylor Otwell</h1>

mask
La maskméthode masque une partie d'une chaîne avec un caractère répété et peut être utilisée pour masquer des segments de chaînes tels que des adresses e-mail et des numéros de téléphone :

use Illuminate\Support\Str;
 
$string = Str::of('taylor@example.com')->mask('*', 3);
 
// tay***************

Si nécessaire, vous fournissez un nombre négatif comme troisième argument à la maskméthode, qui demandera à la méthode de commencer le masquage à la distance donnée de la fin de la chaîne :

$string = Str::of('taylor@example.com')->mask('*', -15, 3);
 
// tay***@example.com

match
La matchméthode renverra la partie d'une chaîne qui correspond à un modèle d'expression régulière donné :

use Illuminate\Support\Str;
 
$result = Str::of('foo bar')->match('/bar/');
 
// 'bar'
 
$result = Str::of('foo bar')->match('/foo (.*)/');
 
// 'bar'

matchAll
La matchAllméthode renverra une collection contenant les parties d'une chaîne qui correspondent à un modèle d'expression régulière donné :

use Illuminate\Support\Str;
 
$result = Str::of('bar foo bar')->matchAll('/bar/');
 
// collect(['bar', 'bar'])

Si vous spécifiez un groupe correspondant dans l'expression, Laravel renverra une collection des correspondances de ce groupe :

use Illuminate\Support\Str;
 
$result = Str::of('bar fun bar fly')->matchAll('/f(\w*)/');
 
// collect(['un', 'ly']);

Si aucune correspondance n'est trouvée, une collection vide sera renvoyée.

newLine
La newLineméthode ajoute un caractère "fin de ligne" à une chaîne :

use Illuminate\Support\Str;
 
$padded = Str::of('Laravel')->newLine()->append('Framework');
 
// 'Laravel
//  Framework'

padBoth
La padBothméthode encapsule la fonction PHP str_pad, remplissant les deux côtés d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::of('James')->padBoth(10, '_');
 
// '__James___'
 
$padded = Str::of('James')->padBoth(10);
 
// '  James   '

padLeft
La padLeftméthode encapsule la fonction PHP str_pad, remplissant le côté gauche d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::of('James')->padLeft(10, '-=');
 
// '-=-=-James'
 
$padded = Str::of('James')->padLeft(10);
 
// '     James'

padRight
La padRightméthode encapsule la fonction PHP str_pad, remplissant le côté droit d'une chaîne avec une autre chaîne jusqu'à ce que la chaîne finale atteigne la longueur souhaitée :

use Illuminate\Support\Str;
 
$padded = Str::of('James')->padRight(10, '-');
 
// 'James-----'
 
$padded = Str::of('James')->padRight(10);
 
// 'James     '

pipe
La pipeméthode vous permet de transformer la chaîne en passant sa valeur actuelle à l'appelable donné :

use Illuminate\Support\Str;
 
$hash = Str::of('Laravel')->pipe('md5')->prepend('Checksum: ');
 
// 'Checksum: a5c95b86291ea299fcbe64458ed12702'
 
$closure = Str::of('foo')->pipe(function ($str) {
    return 'bar';
});
 
// 'bar'

plural
La pluralméthode convertit une chaîne de mots au singulier en sa forme plurielle. Cette fonction prend en charge toutes les langues prises en charge par le pluraliseur de Laravel :

use Illuminate\Support\Str;
 
$plural = Str::of('car')->plural();
 
// cars
 
$plural = Str::of('child')->plural();
 
// children

Vous pouvez fournir un entier comme deuxième argument à la fonction pour récupérer la forme singulière ou plurielle de la chaîne :

use Illuminate\Support\Str;
 
$plural = Str::of('child')->plural(2);
 
// children
 
$plural = Str::of('child')->plural(1);
 
// child

prepend
La prependméthode ajoute les valeurs données au début de la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('Framework')->prepend('Laravel ');
 
// Laravel Framework

remove
La removeméthode supprime la valeur ou le tableau de valeurs donné de la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('Arkansas is quite beautiful!')->remove('quite');
 
// Arkansas is beautiful!

Vous pouvez également passer falsecomme deuxième paramètre pour ignorer la casse lors de la suppression de chaînes.

replace
La replaceméthode remplace une chaîne donnée dans la chaîne :

use Illuminate\Support\Str;
 
$replaced = Str::of('Laravel 6.x')->replace('6.x', '7.x');
 
// Laravel 7.x

replaceArray
La replaceArrayméthode remplace séquentiellement une valeur donnée dans la chaîne à l'aide d'un tableau :

use Illuminate\Support\Str;
 
$string = 'The event will take place between ? and ?';
 
$replaced = Str::of($string)->replaceArray('?', ['8:30', '9:00']);
 
// The event will take place between 8:30 and 9:00

replaceFirst
La replaceFirstméthode remplace la première occurrence d'une valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceFirst('the', 'a');
 
// a quick brown fox jumps over the lazy dog

replaceLast
La replaceLastméthode remplace la dernière occurrence d'une valeur donnée dans une chaîne :

use Illuminate\Support\Str;
 
$replaced = Str::of('the quick brown fox jumps over the lazy dog')->replaceLast('the', 'a');
 
// the quick brown fox jumps over a lazy dog

replaceMatches
La replaceMatchesméthode remplace toutes les parties d'une chaîne correspondant à un modèle par la chaîne de remplacement donnée :

use Illuminate\Support\Str;
 
$replaced = Str::of('(+1) 501-555-1000')->replaceMatches('/[^A-Za-z0-9]++/', '')
 
// '15015551000'

La replaceMatchesméthode accepte également une fermeture qui sera invoquée avec chaque partie de la chaîne correspondant au modèle donné, vous permettant d'effectuer la logique de remplacement dans la fermeture et de renvoyer la valeur remplacée :

use Illuminate\Support\Str;
 
$replaced = Str::of('123')->replaceMatches('/\d/', function ($match) {
    return '['.$match[0].']';
});
 
// '[1][2][3]'

rtrim
La rtrimméthode coupe le côté droit de la chaîne donnée :

use Illuminate\Support\Str;
 
$string = Str::of('  Laravel  ')->rtrim();
 
// '  Laravel'
 
$string = Str::of('/Laravel/')->rtrim('/');
 
// '/Laravel'

scan
La scanméthode analyse l'entrée d'une chaîne dans une collection selon un format pris en charge par la sscanffonction PHP :

use Illuminate\Support\Str;
 
$collection = Str::of('filename.jpg')->scan('%[^.].%s');
 
// collect(['filename', 'jpg'])

singular
La singularméthode convertit une chaîne en sa forme singulière. Cette fonction prend en charge toutes les langues prises en charge par le pluraliseur de Laravel :

use Illuminate\Support\Str;
 
$singular = Str::of('cars')->singular();
 
// car
 
$singular = Str::of('children')->singular();
 
// child

slug
La slugméthode génère un "slug" convivial pour l'URL à partir de la chaîne donnée :

use Illuminate\Support\Str;
 
$slug = Str::of('Laravel Framework')->slug('-');
 
// laravel-framework

snake
La snakeméthode convertit la chaîne donnée en snake_case:

use Illuminate\Support\Str;
 
$converted = Str::of('fooBar')->snake();
 
// foo_bar

split
La splitméthode divise une chaîne en une collection à l'aide d'une expression régulière :

use Illuminate\Support\Str;
 
$segments = Str::of('one, two, three')->split('/[\s,]+/');
 
// collect(["one", "two", "three"])

squish
La squishméthode supprime tous les espaces blancs superflus d'une chaîne, y compris les espaces blancs superflus entre les mots :

use Illuminate\Support\Str;
 
$string = Str::of('    laravel    framework    ')->squish();
 
// laravel framework

start
La startméthode ajoute une seule instance de la valeur donnée à une chaîne si elle ne commence pas déjà par cette valeur :

use Illuminate\Support\Str;
 
$adjusted = Str::of('this/string')->start('/');
 
// /this/string
 
$adjusted = Str::of('/this/string')->start('/');
 
// /this/string

startsWith
La startsWithméthode détermine si la chaîne donnée commence par la valeur donnée :

use Illuminate\Support\Str;
 
$result = Str::of('This is my name')->startsWith('This');
 
// true

studly
La studlyméthode convertit la chaîne donnée en StudlyCase:

use Illuminate\Support\Str;
 
$converted = Str::of('foo_bar')->studly();
 
// FooBar

substr
La substrméthode renvoie la partie de la chaîne spécifiée par les paramètres start et length donnés :

use Illuminate\Support\Str;
 
$string = Str::of('Laravel Framework')->substr(8);
 
// Framework
 
$string = Str::of('Laravel Framework')->substr(8, 5);
 
// Frame

substrReplace
La substrReplaceméthode remplace le texte dans une partie d'une chaîne, en commençant à la position spécifiée par le deuxième argument et en remplaçant le nombre de caractères spécifié par le troisième argument. Le passage 0au troisième argument de la méthode insère la chaîne à la position spécifiée sans remplacer aucun des caractères existants dans la chaîne :

use Illuminate\Support\Str;
 
$string = Str::of('1300')->substrReplace(':', 2);
 
// 13:
 
$string = Str::of('The Framework')->substrReplace(' Laravel', 3, 0);
 
// The Laravel Framework

swap
La swapméthode remplace plusieurs valeurs dans la chaîne à l'aide de la strtrfonction PHP :

use Illuminate\Support\Str;
 
$string = Str::of('Tacos are great!')
    ->swap([
        'Tacos' => 'Burritos',
        'great' => 'fantastic',
    ]);
 
// Burritos are fantastic!

tap
La tapméthode passe la chaîne à la fermeture donnée, vous permettant d'examiner et d'interagir avec la chaîne sans affecter la chaîne elle-même. La chaîne d'origine est renvoyée par la tapméthode indépendamment de ce qui est renvoyé par la fermeture :

use Illuminate\Support\Str;
 
$string = Str::of('Laravel')
    ->append(' Framework')
    ->tap(function ($string) {
        dump('String after append: '.$string);
    })
    ->upper();
 
// LARAVEL FRAMEWORK

test
La testméthode détermine si une chaîne correspond au modèle d'expression régulière donné :

use Illuminate\Support\Str;
 
$result = Str::of('Laravel Framework')->test('/Laravel/');
 
// true

title
La titleméthode convertit la chaîne donnée en Title Case:

use Illuminate\Support\Str;
 
$converted = Str::of('a nice title uses the correct case')->title();
 
// A Nice Title Uses The Correct Case

trim
La trimméthode coupe la chaîne donnée :

use Illuminate\Support\Str;
 
$string = Str::of('  Laravel  ')->trim();
 
// 'Laravel'
 
$string = Str::of('/Laravel/')->trim('/');
 
// 'Laravel'

ucfirst
La ucfirstméthode renvoie la chaîne donnée avec le premier caractère en majuscule :

use Illuminate\Support\Str;
 
$string = Str::of('foo bar')->ucfirst();
 
// Foo bar

ucsplit
La ucsplitméthode divise la chaîne donnée en une collection par des caractères majuscules :

use Illuminate\Support\Str;
 
$string = Str::of('Foo Bar')->ucsplit();
 
// collect(['Foo', 'Bar'])

upper
La upperméthode convertit la chaîne donnée en majuscule :

use Illuminate\Support\Str;
 
$adjusted = Str::of('laravel')->upper();
 
// LARAVEL

when
La whenméthode invoque la fermeture donnée si une condition donnée est true. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('Taylor')
                ->when(true, function ($string) {
                    return $string->append(' Otwell');
                });
 
// 'Taylor Otwell'

Si nécessaire, vous pouvez passer une autre fermeture comme troisième paramètre à la whenméthode. Cette fermeture s'exécutera si le paramètre de condition est évalué à false.

whenContains
La whenContainsméthode appelle la fermeture donnée si la chaîne contient la valeur donnée. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('tony stark')
            ->whenContains('tony', function ($string) {
                return $string->title();
            });
 
// 'Tony Stark'

Si nécessaire, vous pouvez passer une autre fermeture comme troisième paramètre à la whenméthode. Cette fermeture s'exécutera si la chaîne ne contient pas la valeur donnée.

Vous pouvez également passer un tableau de valeurs pour déterminer si la chaîne donnée contient l'une des valeurs du tableau :

use Illuminate\Support\Str;
 
$string = Str::of('tony stark')
            ->whenContains(['tony', 'hulk'], function ($string) {
                return $string->title();
            });
 
// Tony Stark

whenContainsAll
La whenContainsAllméthode invoque la fermeture donnée si la chaîne contient toutes les sous-chaînes données. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('tony stark')
                ->whenContainsAll(['tony', 'stark'], function ($string) {
                    return $string->title();
                });
 
// 'Tony Stark'

Si nécessaire, vous pouvez passer une autre fermeture comme troisième paramètre à la whenméthode. Cette fermeture s'exécutera si le paramètre de condition est évalué à false.

whenEmpty
La whenEmptyméthode invoque la fermeture donnée si la chaîne est vide. Si la fermeture renvoie une valeur, cette valeur sera également renvoyée par la whenEmptyméthode. Si la fermeture ne renvoie pas de valeur, l'instance de chaîne fluide sera renvoyée :

use Illuminate\Support\Str;
 
$string = Str::of('  ')->whenEmpty(function ($string) {
    return $string->trim()->prepend('Laravel');
});
 
// 'Laravel'

whenNotEmpty
La whenNotEmptyméthode invoque la fermeture donnée si la chaîne n'est pas vide. Si la fermeture renvoie une valeur, cette valeur sera également renvoyée par la whenNotEmptyméthode. Si la fermeture ne renvoie pas de valeur, l'instance de chaîne fluide sera renvoyée :

use Illuminate\Support\Str;
 
$string = Str::of('Framework')->whenNotEmpty(function ($string) {
    return $string->prepend('Laravel ');
});
 
// 'Laravel Framework'

whenStartsWith
La whenStartsWithméthode invoque la fermeture donnée si la chaîne commence par la sous-chaîne donnée. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('disney world')->whenStartsWith('disney', function ($string) {
    return $string->title();
});
 
// 'Disney World'

whenEndsWith
La whenEndsWithméthode invoque la fermeture donnée si la chaîne se termine par la sous-chaîne donnée. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('disney world')->whenEndsWith('world', function ($string) {
    return $string->title();
});
 
// 'Disney World'

whenExactly
La whenExactlyméthode appelle la fermeture donnée si la chaîne correspond exactement à la chaîne donnée. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('laravel')->whenExactly('laravel', function ($string) {
    return $string->title();
});
 
// 'Laravel'

whenIs
La whenIsméthode appelle la fermeture donnée si la chaîne correspond à un modèle donné. Les astérisques peuvent être utilisés comme valeurs génériques. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('foo/bar')->whenIs('foo/*', function ($string) {
    return $string->append('/baz');
});
 
// 'foo/bar/baz'

whenIsAscii
La whenIsAsciiméthode invoque la fermeture donnée si la chaîne est en ASCII 7 bits. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('foo/bar')->whenIsAscii('laravel', function ($string) {
    return $string->title();
});
 
// 'Laravel'

whenIsUuid
La whenIsUuidméthode appelle la fermeture donnée si la chaîne est un UUID valide. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('foo/bar')->whenIsUuid('a0a2a2d2-0b87-4a18-83f2-2529882be2de', function ($string) {
    return $string->substr(0, 8);
});
 
// 'a0a2a2d2'

whenTest
La whenTestméthode appelle la fermeture donnée si la chaîne correspond à l'expression régulière donnée. La fermeture recevra l'instance de chaîne fluide :

use Illuminate\Support\Str;
 
$string = Str::of('laravel framework')->whenTest('/laravel/', function ($string) {
    return $string->title();
});
 
// 'Laravel Framework'

wordCount
La wordCountméthode renvoie le nombre de mots que contient une chaîne :

use Illuminate\Support\Str;
 
Str::of('Hello, world!')->wordCount(); // 2

words
La wordsméthode limite le nombre de mots dans une chaîne. Si nécessaire, vous pouvez spécifier une chaîne supplémentaire qui sera ajoutée à la chaîne tronquée :

use Illuminate\Support\Str;
 
$string = Str::of('Perfectly balanced, as all things should be.')->words(3, ' >>>');
 
// Perfectly balanced, as >>>

URL
action()
La actionfonction génère une URL pour l'action de contrôleur donnée :

use App\Http\Controllers\HomeController;
 
$url = action([HomeController::class, 'index']);

Si la méthode accepte les paramètres de route, vous pouvez les passer comme deuxième argument à la méthode :

$url = action([UserController::class, 'profile'], ['id' => 1]);

asset()
La assetfonction génère une URL pour un actif en utilisant le schéma actuel de la requête (HTTP ou HTTPS) :

$url = asset('img/photo.jpg');

Vous pouvez configurer l'hôte de l'URL de l'actif en définissant la ASSET_URLvariable dans votre .envfichier. Cela peut être utile si vous hébergez vos assets sur un service externe comme Amazon S3 ou un autre CDN :

// ASSET_URL=http://example.com/assets
 
$url = asset('img/photo.jpg'); // http://example.com/assets/img/photo.jpg

route()
La routefonction génère une URL pour une route nommée donnée :

$url = route('route.name');

Si la route accepte des paramètres, vous pouvez les passer comme deuxième argument à la fonction :

$url = route('route.name', ['id' => 1]);

Par défaut, la routefonction génère une URL absolue. Si vous souhaitez générer une URL relative, vous pouvez passer falseen troisième argument à la fonction :

$url = route('route.name', ['id' => 1], false);

secure_asset()
La secure_assetfonction génère une URL pour un élément à l'aide de HTTPS :

$url = secure_asset('img/photo.jpg');

secure_url()
La secure_urlfonction génère une URL HTTPS complète vers le chemin donné. Des segments d'URL supplémentaires peuvent être passés dans le deuxième argument de la fonction :

$url = secure_url('user/profile');
 
$url = secure_url('user/profile', [1]);

to_route()
La to_routefonction génère une réponse HTTP de redirection pour une route nommée donnée :

return to_route('users.show', ['user' => 1]);

Si nécessaire, vous pouvez transmettre le code d'état HTTP qui doit être attribué à la redirection et tout en-tête de réponse supplémentaire comme troisième et quatrième arguments de la to_routeméthode :

return to_route('users.show', ['user' => 1], 302, ['X-Framework' => 'Laravel']);

url()
La urlfonction génère une URL complète vers le chemin donné :

$url = url('user/profile');
 
$url = url('user/profile', [1]);

Si aucun chemin n'est fourni, une Illuminate\Routing\UrlGeneratorinstance est renvoyée :

$current = url()->current();
 
$full = url()->full();
 
$previous = url()->previous();

Divers
abort()
La abortfonction lève une exception HTTP qui sera rendue par le gestionnaire d'exception :

abort(403);

Vous pouvez également fournir le message de l'exception et les en-têtes de réponse HTTP personnalisés qui doivent être envoyés au navigateur :

abort(403, 'Unauthorized.', $headers);

abort_if()
La abort_iffonction lève une exception HTTP si une expression booléenne donnée est évaluée àtrue :

abort_if(! Auth::user()->isAdmin(), 403);

Comme la abortméthode, vous pouvez également fournir le texte de réponse de l'exception comme troisième argument et un tableau d'en-têtes de réponse personnalisés comme quatrième argument de la fonction.

abort_unless()
La abort_unlessfonction lève une exception HTTP si une expression booléenne donnée est évaluée àfalse :

abort_unless(Auth::user()->isAdmin(), 403);

Comme la abortméthode, vous pouvez également fournir le texte de réponse de l'exception comme troisième argument et un tableau d'en-têtes de réponse personnalisés comme quatrième argument de la fonction.

app()
La appfonction renvoie l' instance du conteneur de services :

$container = app();

Vous pouvez passer un nom de classe ou d'interface pour le résoudre à partir du conteneur :

$api = app('HelpSpot\API');

auth()
La authfonction renvoie une instance d' authentificateur . Vous pouvez l'utiliser comme alternative à la Authfaçade :

$user = auth()->user();

Si nécessaire, vous pouvez spécifier à quelle instance de garde vous souhaitez accéder :

$user = auth('admin')->user();

back()
La backfonction génère une réponse HTTP de redirection vers l'emplacement précédent de l'utilisateur :

return back($status = 302, $headers = [], $fallback = '/');
 
return back();

bcrypt()
La bcryptfonction hache la valeur donnée en utilisant Bcrypt. Vous pouvez utiliser cette fonction comme alternative à la Hashfaçade :

$password = bcrypt('my-secret-password');

blank()
La blankfonction détermine si la valeur donnée est "vide":

blank('');
blank('   ');
blank(null);
blank(collect());
 
// true
 
blank(0);
blank(true);
blank(false);
 
// false

Pour l'inverse de blank, voir la filledméthode.

broadcast()
La broadcastfonction diffuse l' événement donné à ses écouteurs :

broadcast(new UserRegistered($user));
 
broadcast(new UserRegistered($user))->toOthers();

cache()
La cachefonction peut être utilisée pour obtenir des valeurs du cache . Si la clé donnée n'existe pas dans le cache, une valeur par défaut facultative sera renvoyée :

$value = cache('key');
 
$value = cache('key', 'default');

Vous pouvez ajouter des éléments au cache en passant un tableau de paires clé/valeur à la fonction. Vous devez également transmettre le nombre de secondes ou la durée pendant laquelle la valeur mise en cache doit être considérée comme valide :

cache(['key' => 'value'], 300);
 
cache(['key' => 'value'], now()->addSeconds(10));

class_uses_recursive()
La class_uses_recursivefonction renvoie tous les traits utilisés par une classe, y compris les traits utilisés par toutes ses classes parentes :

$traits = class_uses_recursive(App\Models\User::class);

collect()
La collectfonction crée une instance de collection à partir de la valeur donnée :

$collection = collect(['taylor', 'abigail']);

config()
La configfonction obtient la valeur d'une variable de configuration . Les valeurs de configuration sont accessibles à l'aide de la syntaxe "point", qui comprend le nom du fichier et l'option à laquelle vous souhaitez accéder. Une valeur par défaut peut être spécifiée et est renvoyée si l'option de configuration n'existe pas :

$value = config('app.timezone');
 
$value = config('app.timezone', $default);

Vous pouvez définir des variables de configuration lors de l'exécution en transmettant un tableau de paires clé/valeur. Cependant, notez que cette fonction n'affecte que la valeur de configuration de la requête actuelle et ne met pas à jour vos valeurs de configuration réelles :

config(['app.debug' => true]);

cookie()
La cookiefonction crée une nouvelle instance de cookie :

$cookie = cookie('name', 'value', $minutes);

csrf_field()
La csrf_fieldfonction génère un champ de saisie HTML hiddencontenant la valeur du jeton CSRF. Par exemple, en utilisant la syntaxe Blade :

{{ csrf_field() }}

csrf_token()
La csrf_tokenfonction récupère la valeur du jeton CSRF actuel :

$token = csrf_token();

decrypt()
La decryptfonction décrypte la valeur donnée. Vous pouvez utiliser cette fonction comme alternative à la Cryptfaçade :

$password = decrypt($value);

dd()
La ddfonction vide les variables données et termine l'exécution du script :

dd($value);
 
dd($value1, $value2, $value3, ...);

Si vous ne souhaitez pas interrompre l'exécution de votre script, utilisez dumpplutôt la fonction.

dispatch()
La dispatchfonction pousse le travail donné dans la file d'attente des travaux Laravel :

dispatch(new App\Jobs\SendEmails);

dump()
La dumpfonction vide les variables données :

dump($value);
 
dump($value1, $value2, $value3, ...);

Si vous souhaitez arrêter l'exécution du script après avoir vidé les variables, utilisez ddplutôt la fonction.

encrypt()
La encryptfonction chiffre la valeur donnée. Vous pouvez utiliser cette fonction comme alternative à la Cryptfaçade :

$secret = encrypt('my-secret-value');

env()
La envfonction récupère la valeur d'une variable d'environnement ou renvoie une valeur par défaut :

$env = env('APP_ENV');
 
$env = env('APP_ENV', 'production');


Si vous exécutez la config:cachecommande pendant votre processus de déploiement, vous devez vous assurer que vous n'appelez la envfonction qu'à partir de vos fichiers de configuration. Une fois la configuration mise en cache, le .envfichier ne sera pas chargé et tous les appels à la envfonction renverront null.


event()
La eventfonction distribue l' événement donné à ses écouteurs :

event(new UserRegistered($user));

fake()
La fakefonction résout un singleton Faker à partir du conteneur, ce qui peut être utile lors de la création de fausses données dans les fabriques de modèles, l'amorçage de la base de données, les tests et les vues de prototypage :

@for($i = 0; $i < 10; $i++)
    <dl>
        <dt>Name</dt>
        <dd>{{ fake()->name() }}</dd>
 
        <dt>Email</dt>
        <dd>{{ fake()->unique()->safeEmail() }}</dd>
    </dl>
@endfor

Par défaut, la fakefonction utilisera l' app.faker_localeoption de configuration dans votre config/app.phpfichier de configuration ; cependant, vous pouvez également spécifier les paramètres régionaux en les transmettant à la fakefonction. Chaque paramètre régional résoudra un singleton individuel :

fake('nl_NL')->name()

filled()
La filledfonction détermine si la valeur donnée n'est pas "vide":

filled(0);
filled(true);
filled(false);
 
// true
 
filled('');
filled('   ');
filled(null);
filled(collect());
 
// false

Pour l'inverse de filled, voir la blankméthode.

info()
La infofonction écrira des informations dans le journal de votre application :

info('Some helpful information!');

Un tableau de données contextuelles peut également être passé à la fonction :

info('User login attempt failed.', ['id' => $user->id]);

logger()
La loggerfonction peut être utilisée pour écrire un debugmessage de niveau dans le journal :

logger('Debug message');

Un tableau de données contextuelles peut également être passé à la fonction :

logger('User has logged in.', ['id' => $user->id]);

Une instance de logger sera retournée si aucune valeur n'est passée à la fonction :

logger()->error('You are not allowed here.');

method_field()
La method_fieldfonction génère un hiddenchamp de saisie HTML contenant la valeur usurpée du verbe HTTP du formulaire. Par exemple, en utilisant la syntaxe Blade :

<form method="POST">
    {{ method_field('DELETE') }}
</form>

now()
La nowfonction crée une nouvelle Illuminate\Support\Carboninstance pour l'heure actuelle :

$now = now();

old()
La oldfonction récupère une ancienne valeur d'entrée flashée dans la session :

$value = old('value');
 
$value = old('value', 'default');

Étant donné que la "valeur par défaut" fournie comme deuxième argument de la oldfonction est souvent un attribut d'un modèle Eloquent, Laravel vous permet de passer simplement l'intégralité du modèle Eloquent comme deuxième argument de la oldfonction. Ce faisant, Laravel supposera que le premier argument fourni à la oldfonction est le nom de l'attribut Eloquent qui doit être considéré comme la "valeur par défaut":

{{ old('name', $user->name) }}
 
// Is equivalent to...
 
{{ old('name', $user) }}

optional()
La optionalfonction accepte n'importe quel argument et vous permet d'accéder aux propriétés ou d'appeler des méthodes sur cet objet. Si l'objet donné est null, les propriétés et les méthodes retourneront nullau lieu de provoquer une erreur :

return optional($user->address)->street;
 
{!! old('name', optional($user)->name) !!}

La optionalfonction accepte également une fermeture comme deuxième argument. La fermeture sera invoquée si la valeur fournie en premier argument n'est pas nulle :

return optional(User::find($id), function ($user) {
    return $user->name;
});

policy()
La policyméthode récupère une instance de stratégie pour une classe donnée :

$policy = policy(App\Models\User::class);

redirect()
La redirectfonction renvoie une réponse HTTP de redirection ou renvoie l'instance du redirecteur si elle est appelée sans argument :

return redirect($to = null, $status = 302, $headers = [], $https = null);
 
return redirect('/home');
 
return redirect()->route('route.name');

report()
La reportfonction signalera une exception à l'aide de votre gestionnaire d'exception :

report($e);

La reportfonction accepte également une chaîne comme argument. Lorsqu'une chaîne est donnée à la fonction, la fonction crée une exception avec la chaîne donnée comme message :

report('Something went wrong.');

request()
La requestfonction renvoie l' instance de requête en cours ou obtient la valeur d'un champ d'entrée à partir de la requête en cours :

$request = request();
 
$value = request('key', $default);

rescue()
La rescuefonction exécute la fermeture donnée et intercepte toutes les exceptions qui se produisent pendant son exécution. Toutes les exceptions interceptées seront envoyées à votre gestionnaire d'exceptions ; cependant, la demande continuera à être traitée :

return rescue(function () {
    return $this->method();
});

Vous pouvez également passer un deuxième argument à la rescuefonction. Cet argument sera la valeur « par défaut » qui doit être renvoyée si une exception se produit lors de l'exécution de la fermeture :

return rescue(function () {
    return $this->method();
}, false);
 
return rescue(function () {
    return $this->method();
}, function () {
    return $this->failure();
});

resolve()
La resolvefonction résout un nom de classe ou d'interface donné en une instance à l'aide du conteneur de service :

$api = resolve('HelpSpot\API');

response()
La responsefonction crée une instance de réponse ou obtient une instance de la fabrique de réponse :

return response('Hello World', 200, $headers);
 
return response()->json(['foo' => 'bar'], 200, $headers);

retry()
La retryfonction tente d'exécuter le rappel donné jusqu'à ce que le seuil de tentative maximal donné soit atteint. Si le rappel ne lève pas d'exception, sa valeur de retour sera renvoyée. Si le rappel lève une exception, il sera automatiquement réessayé. Si le nombre maximal de tentatives est dépassé, l'exception sera levée :

return retry(5, function () {
    // Attempt 5 times while resting 100ms between attempts...
}, 100);

Si vous souhaitez calculer manuellement le nombre de millisecondes de sommeil entre les tentatives, vous pouvez passer une fermeture comme troisième argument à la retryfonction :

return retry(5, function () {
    // ...
}, function ($attempt, $exception) {
    return $attempt * 100;
});

Pour plus de commodité, vous pouvez fournir un tableau comme premier argument de la retryfonction. Ce tableau sera utilisé pour déterminer le nombre de millisecondes à mettre en veille entre les tentatives suivantes :

return retry([100, 200], function () {
    // Sleep for 100ms on first retry, 200ms on second retry...
});

Pour ne réessayer que dans des conditions spécifiques, vous pouvez passer une fermeture comme quatrième argument à la retryfonction :

return retry(5, function () {
    // ...
}, 100, function ($exception) {
    return $exception instanceof RetryException;
});

session()
La sessionfonction peut être utilisée pour obtenir ou définir des valeurs de session :

$value = session('key');

Vous pouvez définir des valeurs en passant un tableau de paires clé/valeur à la fonction :

session(['chairs' => 7, 'instruments' => 3]);

Le magasin de session sera retourné si aucune valeur n'est passée à la fonction :

$value = session()->get('key');
 
session()->put('key', $value);

tap()
La tapfonction accepte deux arguments : un arbitraire $valueet une fermeture. Le $valuesera passé à la fermeture et sera ensuite renvoyé par la tapfonction. La valeur de retour de la fermeture n'est pas pertinente :

$user = tap(User::first(), function ($user) {
    $user->name = 'taylor';
 
    $user->save();
});

Si aucune fermeture n'est passée à la tapfonction, vous pouvez appeler n'importe quelle méthode sur le $value. La valeur de retour de la méthode que vous appelez sera toujours $value, quel que soit ce que la méthode retourne réellement dans sa définition. Par exemple, la méthode Eloquent updaterenvoie généralement un entier. Cependant, nous pouvons forcer la méthode à renvoyer le modèle lui-même en enchaînant l' updateappel de la méthode via la tapfonction :

$user = tap($user)->update([
    'name' => $name,
    'email' => $email,
]);

Pour ajouter une tapméthode à une classe, vous pouvez ajouter le Illuminate\Support\Traits\Tappabletrait à la classe. La tapméthode de ce trait accepte une fermeture comme seul argument. L'instance d'objet elle-même sera passée à Closure puis renvoyée par la tapméthode :

return $user->tap(function ($user) {
    //
});

throw_if()
La throw_iffonction lève l'exception donnée si une expression booléenne donnée est évaluée àtrue :

throw_if(! Auth::user()->isAdmin(), AuthorizationException::class);
 
throw_if(
    ! Auth::user()->isAdmin(),
    AuthorizationException::class,
    'You are not allowed to access this page.'
);

throw_unless()
La throw_unlessfonction lève l'exception donnée si une expression booléenne donnée est évaluée àfalse :

throw_unless(Auth::user()->isAdmin(), AuthorizationException::class);
 
throw_unless(
    Auth::user()->isAdmin(),
    AuthorizationException::class,
    'You are not allowed to access this page.'
);

today()
La todayfonction crée une nouvelle Illuminate\Support\Carboninstance pour la date actuelle :

$today = today();

trait_uses_recursive()
La trait_uses_recursivefonction renvoie tous les traits utilisés par un trait :

$traits = trait_uses_recursive(\Illuminate\Notifications\Notifiable::class);

transform()
La transformfonction exécute une fermeture sur une valeur donnée si la valeur n'est pas vide puis renvoie la valeur de retour de la fermeture :

$callback = function ($value) {
    return $value * 2;
};
 
$result = transform(5, $callback);
 
// 10

Une valeur par défaut ou une fermeture peut être passée comme troisième argument à la fonction. Cette valeur sera retournée si la valeur donnée est vide :

$result = transform(null, $callback, 'The value is blank');
 
// The value is blank

validator()
La validatorfonction crée une nouvelle instance de validateur avec les arguments donnés. Vous pouvez l'utiliser comme alternative à la Validatorfaçade :

$validator = validator($data, $rules, $messages);

value()
La valuefonction renvoie la valeur qui lui est donnée. Cependant, si vous passez une fermeture à la fonction, la fermeture sera exécutée et sa valeur retournée sera renvoyée :

$result = value(true);
 
// true
 
$result = value(function () {
    return false;
});
 
// false

view()
La viewfonction récupère une instance de vue :

return view('auth.login');

with()
La withfonction renvoie la valeur qui lui est donnée. Si une fermeture est passée comme deuxième argument à la fonction, la fermeture sera exécutée et sa valeur renvoyée sera renvoyée :

$callback = function ($value) {
    return is_numeric($value) ? $value * 2 : 0;
};
 
$result = with(5, $callback);
 
// 10
 
$result = with(null, $callback);
 
// 0
 
$result = with(5, null);
 
// 5